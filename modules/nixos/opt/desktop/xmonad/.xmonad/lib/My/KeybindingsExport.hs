{-# LANGUAGE LambdaCase #-}
-- |
-- Module      : My.KeybindingsExport
-- Description : Export XMonad keybindings to HTML visualization
--
-- This module exports XMonad keybindings to a self-contained HTML file
-- that can be opened in a web browser.
--
-- == How it works
--
-- 1. On XMonad startup, 'exportKeybindings' is called from the startup hook
-- 2. It reads the shared HTML template from @lib/keybinding-template.html@ (repo root)
-- 3. It extracts categories and keybindings from 'allKeysStructured'
-- 4. Generates compact JS data: appConfig, categories (id→name), keybindings as arrays
-- 5. Colors are assigned cyclically in the template JS, not here
-- 6. Keys are parsed from combo strings in the template JS, not here
-- 7. The HTML is written to @~/.cache/nixos-config/keybinding/xmonad/index.html@
-- 8. The main index page is regenerated via 'my-generate-keybindings-index'
--
-- == Zero Parsing Approach
--
-- Unlike the old version that parsed 'showKm' string output, this version
-- uses structured data directly from 'allKeysStructured'. No parsing needed!
--
-- == Usage
--
-- Add 'exportKeybindings' to the startup hook in @My.Main@:
--
-- @
-- import My.KeybindingsExport
--
-- myStartupHook :: X ()
-- myStartupHook = do
--   exportKeybindings
--   -- ... other startup actions
-- @

module My.KeybindingsExport (exportKeybindings) where

import XMonad
import My.Keybindings (allKeysStructured)
import My.KeybindingTypes (KeybindingCategory(..), Keybinding(..))
import System.Directory (createDirectoryIfMissing, getHomeDirectory, doesFileExist, copyFile)
import System.FilePath ((</>))
import System.Process (callCommand)
import Data.List (intercalate)

-- | Export keybindings to HTML file
--
-- This is the main entry point. Call this from your startup hook.
exportKeybindings :: X ()
exportKeybindings = do
  -- Ensure output directories exist
  io $ ensureOutputDirs

  -- Copy template to data dir if needed
  io $ copyTemplateIfNeeded

  -- Read HTML template
  template <- io $ readTemplate

  -- Use structured data directly - NO PARSING!
  let categories = allKeysStructured
  let script = generateInlineScript categories

  -- Insert script by replacing placeholder
  let finalHTML = insertScript template script

  -- Write output file
  io $ writeHTMLFile finalHTML

  -- Regenerate main index page
  io $ regenerateMainIndex

-- | Ensure output directories exist
ensureOutputDirs :: IO ()
ensureOutputDirs = do
  home <- getHomeDirectory
  let dataDir = home </> ".xmonad" </> "data"
  let hotkeyDir = home </> ".cache" </> "nixos-config" </> "keybinding" </> "xmonad"
  createDirectoryIfMissing True dataDir
  createDirectoryIfMissing True hotkeyDir

-- | Copy shared template from repo to data dir (always, to pick up changes)
copyTemplateIfNeeded :: IO ()
copyTemplateIfNeeded = do
  home <- getHomeDirectory
  let dataTemplate = home </> ".xmonad" </> "data" </> "keybinding-template.html"
  let repoTemplate = "/home/osv/work/my/nixos-config/lib/keybinding-template.html"
  repoExists <- doesFileExist repoTemplate
  if repoExists
    then copyFile repoTemplate dataTemplate
    else return ()

-- | Read the HTML template
readTemplate :: IO String
readTemplate = do
  home <- getHomeDirectory
  let templatePath = home </> ".xmonad" </> "data" </> "keybinding-template.html"
  readFile templatePath

-- | Write the final HTML file
writeHTMLFile :: String -> IO ()
writeHTMLFile content = do
  home <- getHomeDirectory
  let outputPath = home </> ".cache" </> "nixos-config" </> "keybinding" </> "xmonad" </> "index.html"
  writeFile outputPath content

-- | Regenerate the main keybindings index page
regenerateMainIndex :: IO ()
regenerateMainIndex = callCommand "my-generate-keybindings-index"

-- | Generate inline JavaScript with appConfig, categories, and keybindings data
--
-- New compact format:
--   appConfig = { title: '...', modifiers: { 'M': 'Super', ... } }
--   categories = { 'id': 'Display Name', ... }
--   keybindings = [ ['combo', 'category-id', 'action'], ... ]
--
-- Colors are assigned cyclically in the template JS.
-- Keys are parsed from combo strings in the template JS.
generateInlineScript :: [KeybindingCategory] -> String
generateInlineScript categories =
  "// Auto-generated from structured data - no parsing!\n" ++
  "// Generated by XMonad KeybindingsExport\n" ++
  "// DO NOT EDIT - This file is regenerated on XMonad startup\n\n" ++
  -- appConfig with XMonad modifier map
  "const appConfig = {\n" ++
  "    title: 'XMonad Keybindings',\n" ++
  "    modifiers: { 'M': 'Super', 'C': 'Ctrl', 'S': 'Shift', 'M1': 'Alt', 'M4': 'Super' }\n" ++
  "};\n\n" ++
  -- Simplified categories: just id → name
  "const categories = {\n" ++
  intercalate ",\n" (map categoryEntry categories) ++
  "\n};\n\n" ++
  -- Compact array-format keybindings
  "const keybindings = [\n" ++
  intercalate ",\n" (concatMap categoryBindings categories) ++
  "\n];\n"
  where
    categoryEntry cat =
      "    '" ++ escapeJS (kcId cat) ++ "': '" ++ escapeJS (kcName cat) ++ "'"

    categoryBindings cat =
      let catId = kcId cat
      in map (bindingEntry catId) (kcBindings cat)

    bindingEntry catId b =
      "    ['" ++ escapeJS (kbCombo b) ++ "', " ++
      "'" ++ escapeJS catId ++ "', " ++
      "'" ++ escapeJS (kbAction b) ++ "']"

    -- Escape JavaScript strings (basic)
    -- Note: HTML escaping is done in the template via escapeHtml() function
    escapeJS = concatMap $ \case
      '\\' -> "\\\\"
      '"' -> "\\\""
      '\'' -> "\\'"
      '\n' -> "\\n"
      c -> [c]

-- | Insert script content by replacing APP_KEYBINDING_DATA placeholder
insertScript :: String -> String -> String
insertScript template script =
  let placeholder = "app_keybinding_data"
  in case breakOn placeholder template of
       (before, after) ->
         if null after
         then template ++ script  -- Fallback if placeholder not found
         else before ++ script ++ drop (length placeholder) after

-- | Break string at first occurrence of delimiter
breakOn :: String -> String -> (String, String)
breakOn delim str =
  case findIndexHelper (isPrefixOfHelper delim) str of
    Nothing -> (str, "")
    Just idx -> splitAtHelper idx str

-- | Find index in string
findIndexHelper :: (String -> Bool) -> String -> Maybe Int
findIndexHelper _ [] = Nothing
findIndexHelper p str
  | p str = Just 0
  | otherwise = (1 +) <$> findIndexHelper p (tail str)

-- | Check if first string is prefix of second
isPrefixOfHelper :: String -> String -> Bool
isPrefixOfHelper [] _ = True
isPrefixOfHelper _ [] = False
isPrefixOfHelper (x:xs) (y:ys) = x == y && isPrefixOfHelper xs ys

-- | Split string at index
splitAtHelper :: Int -> String -> (String, String)
splitAtHelper n str = (take n str, drop n str)
