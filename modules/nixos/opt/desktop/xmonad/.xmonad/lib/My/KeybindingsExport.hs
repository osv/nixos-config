{-# LANGUAGE LambdaCase #-}
-- |
-- Module      : My.KeybindingsExport
-- Description : Export XMonad keybindings to HTML visualization
--
-- This module exports XMonad keybindings to a self-contained HTML file
-- that can be opened in a web browser.
--
-- == How it works
--
-- 1. On XMonad startup, 'exportKeybindings' is called from the startup hook
-- 2. It reads the HTML template from @~/.xmonad/data/hotkey-template.html@
-- 3. It extracts categories and keybindings from 'allKeysStructured'
-- 4. Colors are assigned to categories by cycling through the Doom One palette
-- 5. Inline JavaScript is generated with categories and keybindings data
-- 6. The HTML is written to @~/.cache/nixos-config/keybinding/xmonad/index.html@
-- 7. The main index page is regenerated via 'my-generate-keybindings-index'
--
-- == Zero Parsing Approach
--
-- Unlike the old version that parsed 'showKm' string output, this version
-- uses structured data directly from 'allKeysStructured'. No parsing needed!
--
-- == Category Color Assignment
--
-- Colors are assigned to categories in order using a cycle through the
-- predefined Doom One color list.
--
-- == Usage
--
-- Add 'exportKeybindings' to the startup hook in @My.Main@:
--
-- @
-- import My.KeybindingsExport
--
-- myStartupHook :: X ()
-- myStartupHook = do
--   exportKeybindings
--   -- ... other startup actions
-- @

module My.KeybindingsExport (exportKeybindings) where

import XMonad
import My.Keybindings (allKeysStructured)
import My.KeybindingTypes (KeyName(..), KeybindingCategory(..), Keybinding(..), findCategoryById, renderKeyName)
import System.Directory (createDirectoryIfMissing, getHomeDirectory, doesFileExist, copyFile)
import System.FilePath ((</>))
import System.Process (callCommand)
import Data.List (intercalate)

-- | Export keybindings to HTML file
--
-- This is the main entry point. Call this from your startup hook.
exportKeybindings :: X ()
exportKeybindings = do
  -- Ensure output directories exist
  io $ ensureOutputDirs

  -- Copy template to data dir if needed
  io $ copyTemplateIfNeeded

  -- Read HTML template
  template <- io $ readTemplate

  -- Use structured data directly - NO PARSING!
  let categories = allKeysStructured
  let script = generateInlineScript categories

  -- Insert script by replacing placeholder
  let finalHTML = insertScript template script

  -- Write output file
  io $ writeHTMLFile finalHTML

  -- Regenerate main index page
  io $ regenerateMainIndex

-- | Ensure output directories exist
ensureOutputDirs :: IO ()
ensureOutputDirs = do
  home <- getHomeDirectory
  let dataDir = home </> ".xmonad" </> "data"
  let hotkeyDir = home </> ".cache" </> "nixos-config" </> "keybinding" </> "xmonad"
  createDirectoryIfMissing True dataDir
  createDirectoryIfMissing True hotkeyDir

-- | Copy template from repo to data dir if not exists
copyTemplateIfNeeded :: IO ()
copyTemplateIfNeeded = do
  home <- getHomeDirectory
  let dataTemplate = home </> ".xmonad" </> "data" </> "hotkey-template.html"
  let repoTemplate = "/home/osv/work/my/nixos-config/modules/nixos/opt/desktop/xmonad/.xmonad/hotkey-template.html"

  exists <- doesFileExist dataTemplate
  if not exists
    then copyFile repoTemplate dataTemplate
    else return ()

-- | Read the HTML template
readTemplate :: IO String
readTemplate = do
  home <- getHomeDirectory
  let templatePath = home </> ".xmonad" </> "data" </> "hotkey-template.html"
  readFile templatePath

-- | Write the final HTML file
writeHTMLFile :: String -> IO ()
writeHTMLFile content = do
  home <- getHomeDirectory
  let outputPath = home </> ".cache" </> "nixos-config" </> "keybinding" </> "xmonad" </> "index.html"
  writeFile outputPath content

-- | Regenerate the main keybindings index page
regenerateMainIndex :: IO ()
regenerateMainIndex = callCommand "my-generate-keybindings-index"

-- | Doom One theme colors for category assignment
--
-- These colors are cycled through when assigning to categories.
doomOneColors :: [String]
doomOneColors =
  [ "#ff6c6b"  -- Red
  , "#da8548"  -- Orange
  , "#ecbe7b"  -- Yellow
  , "#f0c674"  -- Warm yellow
  , "#98be65"  -- Green
  , "#46d9ff"  -- Cyan
  , "#51afef"  -- Blue
  , "#3071f7"  -- Dark blue
  , "#a9a1e1"  -- Purple
  , "#c678dd"  -- Magenta
  , "#ff6ac1"  -- Pink
  , "#fc7b7b"  -- Light red
  , "#b5bd68"  -- Olive
  , "#a3b8cc"  -- Gray
  , "#be5046"  -- Dark red
  , "#9f7efe"  -- Light purple
  , "#6c71c4"  -- Violet
  ]

-- | Generate inline JavaScript with categories and keybindings data
--
-- This generates JavaScript data structures that can be used by the
-- HTML template to display and filter keybindings.
generateInlineScript :: [KeybindingCategory] -> String
generateInlineScript categories =
  "// Auto-generated from structured data - no parsing!\n" ++
  "// Generated by XMonad KeybindingsExport\n" ++
  "// DO NOT EDIT - This file is regenerated on XMonad startup\n\n" ++
  "const categories = {\n" ++
  intercalate ",\n" (map categoryEntry (zip [0..] categories)) ++
  "\n};\n\n" ++
  "const keybindings = [\n" ++
  intercalate ",\n" (concatMap (categoryBindings (zip [0..] categories)) categories) ++
  "\n];\n"
  where
    categoryEntry (idx, cat) =
      "    '" ++ kcId cat ++ "': { name: '" ++ escapeJS (kcName cat) ++
      "', color: '" ++ doomOneColors !! (idx `mod` length doomOneColors) ++ "' }"

    categoryBindings indexedCats cat =
      let catId = kcId cat
      in map (bindingEntry catId) (kcBindings cat)

    bindingEntry catId b =
      "    { combo: '" ++ escapeJS (kbCombo b) ++ "', " ++
      "keys: [" ++ listQuoted (map renderKeyName (kbKeys b)) ++ "], " ++
      "action: '" ++ escapeJS (kbAction b) ++ "', " ++
      "category: '" ++ catId ++ "'" ++
      chordFields b ++
      " }"

    chordFields b
      | kbIsChord b = ", isChord: true, chordKey: '" ++ getChordKey b ++ "'"
      | otherwise = ""

    getChordKey b = case kbKeys b of
      (_:KeyChar k:_) -> [k]
      _ -> ""

    listQuoted = intercalate ", " . map (\s -> "'" ++ s ++ "'")

    -- Escape JavaScript strings (basic)
    -- Note: HTML escaping is done in the template via escapeHtml() function
    escapeJS = concatMap $ \case
      '\\' -> "\\\\"
      '"' -> "\\\""
      '\'' -> "\\'"
      '\n' -> "\\n"
      c -> [c]

-- | Insert script content by replacing KEYBINDINGS_DATA_PLACEHOLDER
insertScript :: String -> String -> String
insertScript template script =
  let placeholder = "KEYBINDINGS_DATA_PLACEHOLDER"
  in case breakOn placeholder template of
       (before, after) ->
         if null after
         then template ++ script  -- Fallback if placeholder not found
         else before ++ script ++ drop (length placeholder) after

-- | Break string at first occurrence of delimiter
breakOn :: String -> String -> (String, String)
breakOn delim str =
  case findIndexHelper (isPrefixOfHelper delim) str of
    Nothing -> (str, "")
    Just idx -> splitAtHelper idx str

-- | Find index in string
findIndexHelper :: (String -> Bool) -> String -> Maybe Int
findIndexHelper _ [] = Nothing
findIndexHelper p str
  | p str = Just 0
  | otherwise = (1 +) <$> findIndexHelper p (tail str)

-- | Check if first string is prefix of second
isPrefixOfHelper :: String -> String -> Bool
isPrefixOfHelper [] _ = True
isPrefixOfHelper _ [] = False
isPrefixOfHelper (x:xs) (y:ys) = x == y && isPrefixOfHelper xs ys

-- | Split string at index
splitAtHelper :: Int -> String -> (String, String)
splitAtHelper n str = (take n str, drop n str)
